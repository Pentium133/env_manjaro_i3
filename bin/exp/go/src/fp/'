package fp

import "fmt"

type Any = interface{}
type Functor func (Any) Any
type Monad chan Any
type Predicate func (Any) bool
type Option = Monad
type Traversable = Monad

func Cons(elements ... Any) Monad {
  c := make(Monad)
  go func () {
    for _, e := range elements {
      c <- e
    }
    close(c)
  }()

  return c
}

func (m Monad) Foreach(fn func(Any)) {
  fmt.Println("call Foreach")
  go func() {
    for e := range m {
      fmt.Println("> ")
      fn(e)
    }
  }()
}

func (m Monad) Map(fn Functor) Monad {
  c := make(Monad)
  go func() {
    for e := range m {
      c <- fn(e)
    }
    close(c)
  }()
  return c
}

func (m Monad) Filter(p Predicate) Monad {
  c := make(Monad)

  go func() {
    for e:= range m {
      if res := p(e); res {
        c <- e
      }
    }
    close(c)
  }()

  return c
}

func (m Monad) FilterNot(p Predicate) Monad {
  notP := func(e Any) bool {
    return !p(e)
  }
  return m.Filter(notP)
}
