#! /usr/bin/env sh

source util_files
source util_text
source util_collections
source util_logs

cb=''
cb_on=''
left_brace='`'
right_brace=$cont_left
group_delimiter='|'
child_level='·'
NONE='NONE'

TRUE=1
FALSE=0

regex_state="$cb|$cb_on"
regex_level='[·]*'
regex_left_brace='`'
regex_right_brace='`'
regex_group_delimiter='\|'
regex_identity="[-_a-zA-Z0-9]+"

IDX_LEVEL=1
IDX_STATE=2
IDX_BODY=3
IDX_GROUP=4
IDX_ID=5
IDX_TEXT=6


##-- builders ---------------------------------------------------------------------------------------------------
function _to_state(){

  case $1 in
    -o|--open|o|0)
      echo $cb
      ;;
    -c|--close|c|1)
      echo $cb_on
      ;;
    *)
      echo $NONE
    ;;
  esac
}

function _make_body(){
  local group=$1
  local id=$2
  local text=$3

  local body="$left_brace$group$group_delimiter$id$right_brace $text"
  echo $body
}

function _make_line(){
  local level=$1
  local state=$2
  local body=$3
 
  if [[ $level = $NONE ]]; then
    level=""
  fi

  if [[ $state = $cb_on ]]; then
    body="~~$body~~"
  fi

  local line="$level$state $body"
  echo $line
}

function _set_state(){
  local line=$1
  local state=$2

  local level=$(_extract_level $line)
  local body=$(_extract_body $line)
  
  echo $(_make_line $level $state $body)
}

function _to_opened(){
  echo $(_set_state $1 $cb)
}

function _to_closed(){
  echo $(_to_state $1 $cb_on)
}

##-- extractors -------------------------------------------------------------------------------------------------
function _extract_fields(){
  local line=$1
  local regex_line="($regex_level)\s*($regex_state)\s*(\~*$regex_left_brace($regex_identity)\|($regex_identity)$regex_right_brace(.*))"

  local arr=("${(@f)$(strregex $1 $regex_line; echo .)}"); unset 'arr[-1]'

  # if level does not exist
  if [[ ${#arr[@]} = 7 ]]; then
    arr=(${arr[1]} $NONE ${arr[2]} ${arr[3]} ${arr[4]} ${arr[5]} ${arr[6]})
  fi

  local parsed_level=${arr[2]}
  local parsed_state=${arr[3]}
  local parsed_body=$(strunwrap ${arr[4]} '\~' '\~')
  local parsed_group=${arr[5]}
  local parsed_id=${arr[6]}
  local parsed_text=$(strunwrap ${arr[7]} '\~' '\~')
  local fields=(
          $parsed_level
          $parsed_state
          $parsed_body
          $parsed_group
          $parsed_id
          $parsed_text
        )

  for f in ${fields[@]}; do
    echo $f
  done
}

function _extract_field(){
 local fields=("${(@f)$(_extract_fields $1; echo .)}"); unset 'arr[-1]'
 echo ${fields[$2]}
}

function _extract_level(){  
  echo $(_extract_field $1 $IDX_LEVEL) 
}

function _extract_body(){
  echo $(_extract_field $1 $IDX_BODY) 
}

function _extract_state(){
  echo $(_extract_field $1 $IDX_STATE) 
}

function _extract_group(){
  echo $(_extract_field $1 $IDX_GROUP) 
}

function _extract_id(){
  echo $(_extract_field $1 $IDX_ID) 
}

function _extract_text(){
  echo $(_extract_field $1 $IDX_TEXT) 
}

function _split_id(){
  strsplit $1 '-'
}

function _extract_parent_ids(){
  local id=$1
  local ids=("${(@f)$(_split_id $id; echo .)}"); unset 'ids[-1]'
  local len=${#ids[@]}
  local to=$(($len-2))

  for i in ${ids:0:$to}; do
    echo $i
  done
}

function _extract_parent_id(){
  local id=$1
  local parent_ids=("${(@f)$(_extract_parent_ids $id; echo .)}"); unset 'parent_ids[-1]'
  local parent_id=$(mkstring $parent_ids -d='-')

  echo $parent_id
}


function _extract_tail_id(){
  local id=$1
  local ids=("${(@f)$(_split_id $id; echo .)}"); unset 'ids[-1]'
  local len=${#ids[@]}
  
  echo "${ids[$(($len-1))]}"
}

##-- API --------------------------------------------------------------------------------------------------------
function todo_find(){
  local file
  local todo_id
  local subtree=false

  for i in "$@"; do
    case $i in
      -i=*|-id=*)
        todo_id="${i#*=}"
        shift
        ;;
      -s)
        subtree=true
        shift
        ;;
      *)
        file="$i"
        shift
      ;;
    esac
  done

  local regex
  if $subtree ; then
    regex="$regex_left_brace$regex_identity\|$regex_identity*$todo_id$regex_identity*$regex_right_brace"
  else
    regex="$regex_left_brace$regex_identity\|(($regex_identity-$todo_id)|($todo_id))$regex_right_brace"
  fi

  grep -E $regex $file
}

function todo_find_parents(){
  local file=$1
  local id=$2
  local line=$(todo_find $file -id=$id)

  local full_id=$(_extract_id $line)

  local ids=("${(@f)$(_extract_parent_ids $full_id; echo .)}"); unset 'ids[-1]'

  for i in ${ids[@]};do
    todo_find $file -id=$i
  done
}

# mode: 
#  - [open]  -> [node.open, parents.open]
#  - [open]  -> [[node.open, parents.open], subtree.open] [force]
#  - [close] -> [node.checked.close]
#  - [close] -> [node.close, subtree.close] [force]
function todo_set_state(){
  local file
  local id
  local state
  local force=false

  for i in "$@"; do
    case $i in
      -i=*|-id=*)
        id="${i#*=}"
        shift
        ;;
      -s=*|-state=*)
        state=$(_to_state "${i#*=}")
        shift
        ;;
      -f|-force)
        force=true
        shift
        ;;
      *)
        file="$i"
        shift
      ;;
    esac
  done


  local nodes=()

  if [ $state = $cb ]; then
    ## ---- open ------------------------------------------------------
    local parents=("${(@f)$(todo_find_parents $file $id; echo .)}"); unset 'parents[-1]'
    if [ $force = true ]; then
      ## -- open force
      local subtree=("${(@f)$(todo_find $file -id=$id -s; echo .)}"); unset 'subtree[-1]'
      nodes+=("${subtree[@]}" "${parents[@]}")
    else
      ## -- open
      local node=$(todo_find $file -id=$id)
      nodes=($node "${parents[@]}")
    fi

  else
    ## ---- close -----------------------------------------------------
    local subtree=("${(@f)$(todo_find $file -id=$id -s; echo .)}"); unset 'subtree[-1]'
    if [ $force = true ]; then
      ## -- close force
      nodes+=("${subtree[@]}")
    else
      ## -- close
      ### - validate
      local current_node
      local opened=()
      for n in $subtree; do
        local child_id=$(_extract_id $n)
        local child_tail_id=$(_extract_tail_id $child_id)
        local child_state=$(_extract_state $n)

        if [ $child_tail_id = $id ]; then
          current_node=$n
        fi

        if [ $child_state = $cb ] && [ $child_tail_id != $id  ]; then
          opened+=($child_tail_id)
        fi
      done

      if [[ ${#opened[@]} > 0 ]]; then
        log_err "[$id] can't be closed - there are opened subtasks $(mkstring $opened -l='[' -d=',' -r=']')"
        return;
      fi

      nodes+=($current_node)
    fi
  fi

  for n in $nodes[@]; do
    local modified=$(_set_state $n $state)
    file_replace $file $n $modified
  done

}

#@deprecated
function get_opened_subtasks(){
  local file=$1
  local id=$2
  local subtree=("${(@f)$(find_subtree $file $id; echo .)}"); unset 'subtree[-1]'

  local subtree_size=$((${#subtree[@]}-1))

  if [[ $subtree_size = 1 ]];then
    return;

  else
    for e in ${subtree:1};do
      local state=$(_extract_state $e)
      if [[ $state = $cb ]]; then
        echo $(_extract_id $e)
        #return;
      fi
    done

    return;
  fi 
}

#@deprecated
function set_state(){
  local file=$1
  local id=$2
  local state=$(_to_state $3)

  if [ $state = $NONE ];then
    log_err "unknown state $state"
    return;
  fi

  if [ $state = $cb ]; then
    local parents=("${(@f)$(todo_find_parents $file $id; echo .)}"); unset 'parents[-1]'
    for e in ${parents[@]}; do
      local opened_entry=$(_set_state $e $cb)
      file_replace $file $e $opened_entry
      log_info $e
    done
      local e=$(todo_find $file $id)
      opened_entry=$(_set_state $e $cb)
      file_replace $file $e $opened_entry
      log_info $e



  else
    local opened_subids=($(get_opened_subtasks $file $id))
    if [[ ${#opened_subids[@]} > 0 ]]; then
      log_err "task [$id] can't be closed - there are opened subtasks $(mkstring $opened_subids -l='[' -d=',' -r=']')"
      return;
    fi

    local subtree=("${(@f)$(find_subtree $file $id; echo .)}"); unset 'subtree[-1]'
    for e in ${subtree[@]}; do
      local closed_entry=$(_set_state $e $cb_on)
      file_replace $file $e $closed_entry
    done

  fi
}

#@deprecated
function todos(){
  local task
  local file
  local state=()

  for i in "$@"; do
    case $i in
      -t=*|--task=*)
        task="${i#*=}"
        shift
        ;;
      -c|--closed)
        state+=$cb_on
        shift
        ;;
      -o|--opened)
        state+=$cb
        shift
        ;;
      *)
        file="$i"
        shift
      ;;
    esac
  done

  if [ ${#state[@]} -eq 0 ]; then
    state=($cb_on $cb)
  fi


  local regex_curr_state=$(mkstring $state -d='\|')
  local pattern
  if [[ -n $task  ]]; then
    pattern="\($regex_curr_state\)$regex_anychar$regex_left_brace$regex_anychar${task}$regex_anychar$regex_right_brace"
  fi

  find_line $file $pattern
}

#@deprecated
function todo_state(){
  local file
  local task
  local striked=0
  
  for i in "$@"; do
    case $i in
      -t=*|--task=*)
        task="${i#*=}"
        shift
        ;;
      -c|--closed)
        striked=1
        shift
        ;;
      -o|--opened)
        striked=0
        shift
        ;;
      *)
        file="$i"
        shift
      ;;
    esac
  done

  local arr=("${(@f)$(todos $file -t=$task; echo .)}"); unset 'arr[-1]'

  for e in $arr[@];do
    local level=$(_extract_level $e)
    local state=$(_extract_state $e)
    local body=$(_extract_body $e)

    if [[ $level = ' ' ]]; then
      level=''
    fi

    if [[ $striked = 1 ]]; then
      local result="${level}${cb_on} ~~${body}~~"
      
    else
      local result="${level}${cb} ${body}"
    fi

    
    file_replace $file $e $result
  done
}

#@deprecated
function todo_add(){
  local file=$1
  local group=$2
  local text=$3
  local id=$(short_id)
  local full_id=$(_make_path $group $id)
  local result="$cb $full_id $text"

  if newline_at_eof $file; then
    echo $result >> $file
  else
    echo -n $result >> $file
    echo "" >> $file
  fi

  echo $id
}

#@deprecated
function todo_add_child(){
  local file=$1
  local task=$2
  local text=$3

  local arr=("${(@f)$(todos $file -t=$task; echo .)}"); unset 'arr[-1]'

  local line=${arr[1]}
  local parent_level=$(_extract_level $line)
  local parent_group=$(_extract_group $line)
  local parent_id=$(_extract_id $line)
  local id="${parent_id}-$(short_id)"
  local full_id=$(_make_path $parent_group $id)

  if [[ $parent_level = ' ' ]]; then
    parent_level=''
  fi

  local child="${line}\n${parent_level}··$cb $full_id $text"
  

  file_replace $file $line $child

  echo $id
}


